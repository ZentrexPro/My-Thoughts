<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Luxury Dice — Full Feature</title>
<style>
  :root{
    --bg:#f7f7f9;
    --accent1: #00c6ff;
    --accent2: #0072ff;
    --gold: #d4af37;
    --gold-dark: #aa8327;
    --card: #ffffff;
    --muted: #666;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); font-family:Inter,system-ui,Segoe UI,Roboto,Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; overflow:hidden;}
  /* Subtle textured background using layered gradients */
  body::before{
    content:""; position:fixed; inset:0; z-index:0;
    background-image:
      radial-gradient(circle at 10% 20%, rgba(0,0,0,0.015) 0 1px, transparent 1px),
      radial-gradient(circle at 80% 60%, rgba(0,0,0,0.02) 0 1px, transparent 1px);
    background-size: 40px 40px, 60px 60px;
    pointer-events:none;
  }

  /* Container */
  .app{
    position:relative; z-index:1;
    height:100vh; width:100vw;
    display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    padding:20px;
    gap:18px;
  }

  header{
    width:100%; max-width:980px; display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px;
  }
  h1{
    margin:0; font-size:20px; color:#111; letter-spacing:0.2px;
  }

  /* Scoreboard top corners */
  .score {
    display:flex; gap:12px; align-items:center;
  }
  .chip{
    padding:8px 12px; border-radius:999px; font-weight:700; font-size:14px;
    display:inline-flex; gap:8px; align-items:center;
    box-shadow:0 6px 18px rgba(17,24,39,0.06);
  }
  .chip.win{ background:linear-gradient(180deg,#ecfff1,#e6ffed); color:#0b6b2b; border:1px solid #c7f0d1;}
  .chip.loss{ background:linear-gradient(180deg,#fff1f1,#ffefef); color:#a10a10; border:1px solid #ffd6d6;}

  /* Game area */
  .stage{
    width:100%; max-width:980px; display:flex; align-items:center; justify-content:center; gap:30px;
    padding:14px; border-radius:16px; background:linear-gradient(180deg,#ffffff, #fbfbfd);
    box-shadow: 0 10px 30px rgba(17,24,39,0.06);
    position:relative;
  }

  /* Dice column (keeps dice above choices visually) */
  .column {
    display:flex; flex-direction:column; align-items:center; gap:14px;
    width:420px; max-width:48%;
  }

  /* 3D dice using CSS transform */
  .dice-wrap{
    perspective:1200px;
    width:320px; height:320px; display:flex; align-items:center; justify-content:center;
    position:relative;
  }

  .dice {
    width:220px; height:220px;
    transform-style:preserve-3d;
    position:relative;
    transition: transform 3s cubic-bezier(.18,.86,.43,1);
    will-change:transform;
    display:block;
  }

  /* Golden frame glow */
  .dice::after{
    content:"";
    position:absolute; inset:-10px; border-radius:18px;
    background:linear-gradient(90deg, rgba(212,175,55,0.15), rgba(170,131,39,0.12));
    filter:blur(8px);
    z-index:-1;
  }

  /* Each face */
  .face {
    position:absolute; width:100%; height:100%;
    left:0; top:0;
    background:linear-gradient(180deg,#ffffff,#fbfbfb);
    border-radius:18px;
    border:6px solid var(--gold);
    box-shadow: 0 10px 30px rgba(17,24,39,0.08), inset 0 -10px 25px rgba(0,0,0,0.03);
    display:flex; flex-wrap:wrap; align-content:center; justify-content:center;
    padding:14px;
    backface-visibility:hidden;
  }

  /* pip container positions for 1..6 (we will place pip divs) */
  .pip { width:26px; height:26px; border-radius:50%; box-shadow: 0 3px 6px rgba(0,0,0,0.2); }

  /* Transforms for cube faces */
  .front  { transform: translateZ(110px); } /* 1 */
  .back   { transform: rotateY(180deg) translateZ(110px); } /* 3 */
  .right  { transform: rotateY(90deg) translateZ(110px); } /* 2 */
  .left   { transform: rotateY(-90deg) translateZ(110px); } /* 4 */
  .top    { transform: rotateX(90deg) translateZ(110px); } /* 5 */
  .bottom { transform: rotateX(-90deg) translateZ(110px); } /* 6 */

  /* Choices (1-6) shown below the dice on mobile/tablet */
  .choices {
    width:100%; max-width:520px;
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:14px;
    justify-items:center;
  }
  .btn {
    width:140px; height:72px; border-radius:14px; border:none;
    background:linear-gradient(135deg,var(--accent1),var(--accent2)); color:#fff;
    font-weight:800; font-size:20px; cursor:pointer;
    box-shadow: 0 12px 28px rgba(0,0,0,0.08);
    transition: transform .12s ease, box-shadow .12s ease;
  }
  .btn:active { transform: scale(.98) translateY(1px); }
  .btn.glow { box-shadow: 0 18px 40px rgba(0,118,255,0.18); }
  /* Make grid show two rows visually centered beneath dice */
  .controls { display:flex; flex-direction:column; align-items:center; gap:14px; }

  #result {
    margin-top:6px; font-weight:800; font-size:16px; color:#222; min-height:22px;
  }

  /* Win glow animation */
  .win-glow {
    animation: glowPulse 1.2s ease-in-out 3;
    box-shadow: 0 0 40px rgba(16,185,129,0.22), 0 8px 40px rgba(16,185,129,0.12);
  }
  @keyframes glowPulse {
    0%{ transform: scale(1); }
    50%{ transform: scale(1.03); filter:brightness(1.05); }
    100%{ transform: scale(1); filter:brightness(1); }
  }

  /* small screens adjustments */
  @media (max-width:880px){
    .stage{ flex-direction:column; align-items:center; gap:18px; padding:12px; }
    .column{ width:92%; max-width:520px; }
    .dice-wrap{ width:260px; height:260px; }
    .dice{ width:180px; height:180px; }
    .btn{ width:120px; height:64px; font-size:18px; }
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>🎲 Luxury Dice — Premium</h1>
      <div class="score">
        <div class="chip win">Wins: <span id="wins">0</span></div>
        <div style="width:10px"></div>
        <div class="chip loss">Losses: <span id="losses">0</span></div>
      </div>
    </header>

    <main class="stage" role="main" aria-label="Dice game area">
      <div class="column">
        <div class="dice-wrap" aria-hidden="false">
          <div id="dice" class="dice" role="img" aria-label="3D dice">
            <!-- front = 1 -->
            <div class="face front" data-face="1"></div>
            <!-- back = 3 -->
            <div class="face back" data-face="3"></div>
            <!-- right = 2 -->
            <div class="face right" data-face="2"></div>
            <!-- left = 4 -->
            <div class="face left" data-face="4"></div>
            <!-- top = 5 -->
            <div class="face top" data-face="5"></div>
            <!-- bottom = 6 -->
            <div class="face bottom" data-face="6"></div>
          </div>
        </div>

        <div id="result">Pick a number and roll the dice</div>
      </div>

      <div class="column" style="align-items:center;">
        <div class="controls" style="align-items:center;">
          <div class="choices" role="group" aria-label="Pick number">
            <button class="btn" data-n="1">1</button>
            <button class="btn" data-n="2">2</button>
            <button class="btn" data-n="3">3</button>
            <button class="btn" data-n="4">4</button>
            <button class="btn" data-n="5">5</button>
            <button class="btn" data-n="6">6</button>
          </div>
          <div style="display:flex;gap:10px;align-items:center;">
            <label style="font-size:13px;color:var(--muted)">Sound</label>
            <input id="soundToggle" type="checkbox" checked />
          </div>
        </div>
      </div>
    </main>
  </div>

<script>
/* ========= Procedural pips rendering (colors + layout) ========= */
(function setupFaces(){
  // pip layout coordinates normalized (-1..1) positions for 1..6
  const layouts = {
    1:[[0,0]],
    2:[[-0.5,-0.5],[0.5,0.5]],
    3:[[-0.6,-0.6],[0,0],[0.6,0.6]],
    4:[[-0.6,-0.6],[0.6,-0.6],[-0.6,0.6],[0.6,0.6]],
    5:[[-0.6,-0.6],[0.6,-0.6],[0,0],[-0.6,0.6],[0.6,0.6]],
    6:[[-0.55,-0.7],[0.55,-0.7],[-0.55,0], [0.55,0],[-0.55,0.7],[0.55,0.7]]
  };
  const colors = ['#ef4444','#3b82f6','#10b981','#111827','#8b5cf6','#fb923c']; // variety
  document.querySelectorAll('.face').forEach(face=>{
    const f = Number(face.getAttribute('data-face'));
    face.innerHTML = ''; // clear
    const pts = layouts[f] || layouts[1];
    pts.forEach((p,i)=>{
      const d = document.createElement('div');
      d.className = 'pip';
      d.style.background = colors[i % colors.length];
      // absolute positioning inside face, using percent
      const x = 50 + p[0]*40; // p[0] in -1..1 -> percent offset
      const y = 50 + p[1]*40;
      d.style.position = 'absolute';
      d.style.left = `calc(${x}% - 13px)`; // center pip (13px = half width)
      d.style.top  = `calc(${y}% - 13px)`;
      face.appendChild(d);
    });
  });
})();

/* ========= Dice rotation mapping & behavior ========= */
/*
Face mapping (we set above):
 front -> data-face="1"
 right -> 2
 back -> 3
 left -> 4
 top -> 5
 bottom -> 6

Transforms (in degrees) to bring a face to front:
 1 -> rotateX(0)   rotateY(0)
 2 -> rotateX(0)   rotateY(-90)
 3 -> rotateX(0)   rotateY(-180)
 4 -> rotateX(0)   rotateY(90)
 5 -> rotateX(90)  rotateY(0)
 6 -> rotateX(-90) rotateY(0)
*/
const faceTransforms = {
  1: {x:0, y:0},
  2: {x:0, y:-90},
  3: {x:0, y:-180},
  4: {x:0, y:90},
  5: {x:90, y:0},
  6: {x:-90, y:0}
};

const dice = document.getElementById('dice');
const buttons = Array.from(document.querySelectorAll('.btn'));
const resultEl = document.getElementById('result');
const winsEl = document.getElementById('wins');
const lossesEl = document.getElementById('losses');
const soundToggle = document.getElementById('soundToggle');

let wins = 0, losses = 0;
let rolling = false;

/* ========= WebAudio: procedural roll sound & chime ========= */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new AudioCtx();
}
function playRollSound(duration=2800){
  if(!soundToggle.checked) return;
  ensureAudio();
  const ctx = audioCtx;
  // create noise buffer
  const bufferSize = ctx.sampleRate * 1.0;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++){
    data[i] = (Math.random()*2-1) * 0.25; // white noise
  }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;
  // filter to make it more "thumpy"
  const low = ctx.createBiquadFilter();
  low.type = 'lowpass'; low.frequency.value = 1200;
  const gain = ctx.createGain(); gain.gain.value = 0.001;
  // ramp up & down during roll
  gain.gain.cancelScheduledValues(ctx.currentTime);
  gain.gain.setValueAtTime(0.001, ctx.currentTime);
  gain.gain.linearRampToValueAtTime(0.6, ctx.currentTime + 0.12);
  gain.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime + duration/1000 - 0.3);
  gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration/1000);

  const convolver = ctx.createConvolver(); // tiny reverb could be added but left empty
  noise.connect(low); low.connect(gain); gain.connect(ctx.destination);
  noise.start();
  setTimeout(()=>{ try{ noise.stop(); }catch(e){} }, duration);
}

function playChime(success=true){
  if(!soundToggle.checked) return;
  ensureAudio();
  const ctx = audioCtx;
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = 'sine';
  if(success){
    // ascending chime
    o.frequency.setValueAtTime(520, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(920, ctx.currentTime + 0.25);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.18, ctx.currentTime + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.45);
  } else {
    // low sad tone
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(180, ctx.currentTime + 0.3);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, ctx.currentTime + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5);
  }
  o.connect(g); g.connect(ctx.destination);
  o.start();
  o.stop(ctx.currentTime + 0.5);
}

/* ========= Vibration helper ========= */
function vibratePattern(short){
  if(navigator.vibrate){
    navigator.vibrate(short ? 40 : [90,40,120]);
  }
}

/* ========= Main roll logic ========= */
function rollSequence(guess){
  if(rolling) return;
  rolling = true;
  vibratePattern(true);
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume && audioCtx.resume();
  // pick result
  const result = Math.floor(Math.random()*6) + 1;
  resultEl.textContent = 'Rolling...';
  // multi-spin: add many full rotations for visual richness
  const spins = 3 + Math.floor(Math.random()*3); // 3..5 full spins
  const base = faceTransforms[result];
  // compute final angles in degrees, include spins (360 * spins)
  const finalX = base.x + 360 * spins + (Math.random()*140 - 70); // small randomness
  const finalY = base.y + 360 * (spins+1) + (Math.random()*140 - 70);

  // ensure transition time 3s (as requested)
  dice.style.transition = 'transform 3s cubic-bezier(.18,.86,.43,1)';
  // trigger roll sound
  playRollSound(3000);

  // apply transform (note: use rotateX then rotateY)
  requestAnimationFrame(()=>{
    dice.style.transform = `rotateX(${finalX}deg) rotateY(${finalY}deg)`;
  });

  // During roll we may animate small 3D wobble effect (not necessary)

  // After completion (3s), settle to exact face rotation (short smooth settle)
  setTimeout(()=>{
    // Snap to the exact target orientation (no spins) but with small ease
    const snapX = base.x;
    const snapY = base.y;
    dice.style.transition = 'transform 600ms cubic-bezier(.22,.9,.35,1)';
    dice.style.transform = `rotateX(${snapX}deg) rotateY(${snapY}deg)`;

    setTimeout(()=>{
      // done; show result
      if(guess === result){
        wins++;
        winsEl.textContent = wins;
        resultEl.innerHTML = `🎉 <strong>WIN</strong> — You picked ${guess}, dice shows ${result}`;
        // glow effect
        dice.classList.add('win-glow');
        setTimeout(()=> dice.classList.remove('win-glow'), 1200);
        playChime(true);
      } else {
        losses++;
        lossesEl.textContent = losses;
        resultEl.innerHTML = `❌ <strong>LOSE</strong> — You picked ${guess}, dice shows ${result}`;
        playChime(false);
      }
      vibratePattern(false);
      rolling = false;
    }, 650);

  }, 3000 + 20); // a little offset
}

/* ========= Bind UI actions ========= */
buttons.forEach(b=>{
  b.addEventListener('click', e=>{
    const n = Number(b.getAttribute('data-n'));
    // tiny tactile feedback & visual
    b.animate([{transform:'scale(1)'},{transform:'scale(.95)'}],{duration:120,fill:'forwards'});
    b.classList.add('glow');
    setTimeout(()=> b.classList.remove('glow'), 220);
    // fire roll
    rollSequence(n);
  });
});

// allow keyboard 1-6 for quick testing (optional)
document.addEventListener('keydown', e=>{
  if(e.key >= '1' && e.key <= '6'){
    const btn = document.querySelector(`.btn[data-n="${e.key}"]`);
    if(btn) { btn.click(); }
  }
});

// Prevent accidental text selection on long press
document.addEventListener('selectstart', e=> e.preventDefault());

/* Ready state: set initial slight tilt */
dice.style.transform = 'rotateX(10deg) rotateY(-20deg)';

// Unlock audio on first user gesture (some browsers block WebAudio until gesture)
window.addEventListener('pointerdown', function unlockAudio(){
  if(!audioCtx && soundToggle.checked){
    try{ ensureAudio(); }catch(e){}
  }
  window.removeEventListener('pointerdown', unlockAudio);
});
</script>
</body>
              </html>
